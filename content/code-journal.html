<!DOCTYPE html>
<html lang = "en">
    <head>
        <meta charset="utf-8">
        <title>Iris Lux - Junior Developer</title>
        <link href ="../stylesheets/style.css" rel = "stylesheet">
    </head>
    <body>
        <section class="navigation-menu">
            <nav>
                <div class = "nav-link"><a href="index.html">Home</a></div>
                <div class = "nav-link"><a href="about.html">About</a></div>
                <div class = "nav-link"><a href="code-journal.html">Code Journal</a></div>
                <div class = "nav-link"><a href="portfolio.html">Portfolio</a></div>
            </nav>
        </section>
        <section class = "container">
            <header>Code Journal</header>
            <ul class = items>
                <li>
                    <article>
                        <h4>Yoricking</h4>
                        <p>
                            Yoricking is much like rubber-ducking, except the rubber duck is replaced with a human skull, or a facsimile if a real skull is not available. The name comes from Hamlet's dead companion, who's skull Hamlet speaks to throughout the play.
                        </p>
                        <p>
                            Why talk to a skull to work out your code problems instead of a duck?  First off, verisimilitude. It's much easier to imagine you're conversing with a human if you're holding human remains in your hand. Secondly, skulls don't squeak - you can't idly squeak a skull and annoy your coworkers during a work zoom meeting. Thirdly, the skull will remind you of impermanence and the inevitability of death, encouring you to live with spontaneity. I'm not sure how that last one will help you code, but it's a bonus.
                        </p>
                    </article>
                </li>
                <li>
                    <article>
                        <h4>The CSV:Table Class in Ruby</h4>
                        <p>
                            CSV:Tables are two-dimensional objects used to access and manipulate CSV tables. They contain a series of CSV:Row objects, which are similar to arrays but can access elements by both a header and index. CSV:Table and CSV:Row objects both belong to the “Enumerable” module, and thus can access a bevy of methods useful for solving these problems, such as find(), group_by(), and filter().
                        </p>
                    </article>
                </li>
                <li>
                    <article>
                        <h4>How I Got Started in Ruby</h4>
                        <p>
                            A few people close to me are programmers. A couple months ago we chatted about my prior encounters with coding - high school computer science, a grad school SQL class. These talks  reminded me that coding could be a profession that engages my creativity.
                        </p>
                        <p>
                            After those conversations, I began teaching myself Ruby. Initially, I worried that I’d return to code and find it boring. The opposite happened. I fell in love with Ruby.  I scoured the internet for tutorials, starting with basic data types, then proceeding to headier topics: blocks, regular expressions, object-oriented design. Each morsel of knowledge made me crave more.
                        </p>
                        <p>
                            I love the endorphin hit of solving a difficult problem the most. Sure, I enjoy the flow of coding: breaking down a problem, creating a strategy, writing and rewriting the program that solves it. If I were more enlightened, maybe the journey would trump the destination. But when I see code run precisely how it should, I’m so happy I let out a yelp of joy.
                        </p>
                    </article>
                </li>
            </ul>
        </section>
        <footer>Copyright 2020 Iris Lux</footer>
    </body>
</html>